<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!--
This is an example weekly progress report document that team members can use to report their individual progress 
of their ECE477 senior design projects. Weekly progress reports are expected to follow the general guidelines
presented in the "Progress Report Policy" document, posted on Brightspace.  

Please create 4 copies of this example, renaming each copy to <PurdueID>.html, where <PurdueID> corresponds to
the Purdue ITAP Career Account ID given by Purdue to each individual team member. If you have any questions,
contact course staff.
-->
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<!--Reconfigurable base tag; used to modify the site root location for root-relative links-->
<!--<base href="https://engineering.purdue.edu/ece477/StudentWebTemplate/" />-->
<base href="https://engineering.purdue.edu/477grp18/" /> <!-- Replace the N with your team number-->

<!--Content-->
<title>ECE477 Course Documents</title>
<meta name="keywords" content="" />
<meta name="description" content="" />
<meta name="author" content="George Hadley">
<meta name = "format-detection" content = "telephone=no" />
<meta name="viewport" content="width=device-width,initial-scale=1.0">

<!--CSS-->
<link rel="stylesheet" href="css/default.css" type="text/css" media="all" />
<link rel="stylesheet" href="css/responsive.css">
<link rel="stylesheet" href="css/styles.css">
<link rel="stylesheet" href="css/content.css">
<!--[if IE 6]>
<link href="default_ie6.css" rel="stylesheet" type="text/css" />
<![endif]-->

</head>
<body>
<div id="wrapper_site">
    <div id="wrapper_page">
	<!-- Instantiate global site header.-->
	<div id="header"></div>
		<!-- Instantiate site global navigation bar.-->
		<div id="menu"></div>
	
		<!-- Instantiate a page banner image. Page banner images should be 1100x350px and should be located within the local
			img folder located at this directory level. -->
		<div id="banner">
			<img src="Files/img/BannerImgExample.jpg"></img>
		</div>
	
		<!-- Instantiate "tools" needed for a page. Tools are premade functional blocks that can be used to build a page,
			and include things such as a file lister (for listing out homework assignments or tutorials)
		-->
		<div id="content">
			<h4>Week 13:</h4>
            <b>Date:</b> 4/14/23 <br>
            <b>Total hours:</b> 8<br>
            <b>Description of project design efforts:</b><br>
			<p>
				On Saturday, I met with the team to try and figure out the power problem. We didn't make any progress on diagnosing the exact problem but we got everyone on the same page 
				and tried some preliminary tests (seperating the power inputs).
				<br>
				On Sunday, Graeme and I went to Home Depot and purchased all materials required for the display construction, which Graeme will be working solely on.
				
				<br>
				On Monday, I came in for around 30 minutes to help the team where I could with the power problem. We enlisted the help of Joe and I tried to assist him as much as I could.
				<br>
				I was unable to come in until Friday, but I stayed in contact with the team over Discord and tried to contribute. They figured out the power problem with help from Joe.
				On Friday, I got to lab and immediately fixed the debouncing problem in my barebones mode-switching program. Then Kahaan came in and we tried to merge code. It was semi-successful as he 
				did a lot of the heavy moving on merging the ADC code with the Bluetooth functionality he was working on. However, we still have to create the finalized message sending to the LEDs (he started this)
				so we can check off the PSSCs for making LEDs work adaptively. While Graeme was on lab and working on construction, me and him probed into the finished PCB to check our audio signals. 
				They were fine, so now it is up just to me and Kahaan to finish the programs.
				I have attached 2 photo of the circuit that I was using to test the mode switching on and the receipt from the Home Depot trip.
				Documents:<br>
				<img src="Team/progress/progress1pics/red_Debounced.jpg" style="width:200px;height:200px;">
				<img src="Team/progress/progress1pics/green_debounced.jpg" style="width:200px;height:200px;">


				
			</p>

			<h4>Week 12:</h4>
            <b>Date:</b> 4/7/23 <br>
            <b>Total hours:</b> 10<br>
            <b>Description of project design efforts:</b><br>
			<p>
				After lab on Tuesday, Graeme and I got the MCU to load code that I had written. This test was the file TestMCU_CaseLED.c located in our firmware repository.
				This was a good test as it proved that we could power the MCU with the progamming header from the USB connection, proved that the boot/reset buttons worked, and proved 
				that we could use PlatformIO for all programming. It is the first photo attached below.
				<br>
				I came back in after class to work on the LED "message" sending again. I decided to use an RMT library provided by Espressif and it worked perfectly. I packaged the example program into tasks that we can 
				use with FreeRTOS. This program is available in the source code repository as RDNT_Firmware/ProtoTyping Tools/ESP_RMT_LEDs. I have attached a gif of the results of 
				this test (red flashing gif). Now that that component has been tested and proved working, the final step outside of bluetooth connection (that Kahaan is working on) 
				is to package everything into one program. I realized that I wanted to spend the time to really review RTOS before I made stupid mistakes, so I spent 2 hours going through DigiKey's youtube tutorials on RTOS for ESP32 systems.
				
				<br>
				On Wednesday and Thursday, I integrated the case LED functionality with the mode button interrupts. This required design choices and I chose to start making this device a state machine
				for the three different modes. Then the mode button is used to transition between the multiple modes. I realized that then, there must be logic for transitions (which peripherals will be disabled/enabled).
				The file I was working on is listed as TestMCU_ModeCaseLED.c in our firmware repository. I had some trouble and realized I would need to control our button clicks to make buttons signal not force extra mode switches.
				That is missing from the file as I was still experimenting with differnt block task state durations. I have uploaded the results of this test as the 3rd picture, notice that it shows 3 differnt colors.
				This is not the expected behavior, and will be fixed.

				Documents:<br>
				<img src="Team/progress/progress1pics/pcb_white.jpg" style="width:200px;height:200px;">
				<img src="Team/progress/progress1pics/red_flashing.gif" style="width:200px;height:200px;">
				<img src="Team/progress/progress1pics/multi_color.jpg" style="width:200px;height:200px;">
				
			</p>

			<h4>Week 11:</h4>
            <b>Date:</b> 3/31/23 <br>
            <b>Total hours:</b> 8<br>
            <b>Description of project design efforts:</b><br>
			<p>
				This week I started working on the software again. My first goal was to create a program that we can use to check the MCU's functionality when it is soldered on the board. So quickly, I whipped up a program using the 
				Arduino framework that flashes the Case LEDs. Then I began to remake the program in the Espressif-IDF that we will use in our final design. I was attempting to not use any 3rd party libraries or drivers and control everything
				with the LEDC API provided in Espressif-IDF.
				<br>
				
				I had used the FastLED library when I was prototyping with the Arduino Framework so I know that is possible to only use one GPIO pin to drive the LED strips. My first plan was to create PWM signals using APIs in the Espressif-IDF.
				I achieved two succeses: I was able to light up the LEDs with full white and then blink them on a timer. I then tried and failed to the get the system working with different colors or with some of the LEDs lighting up, not the full strip.
				I came to the realization that the API I was using (LEDC) does not have enough control over the PWM signal to be able to use it for our final project. I do not consider this a complete failure however,
				as prior to the failure, I had archetyped a general system for controlling each bit to be used in our message sender. My problem is now to find a timer system that can give me this precise bit control where I require it.
				I began looking at RMT which many LED drivers use. I will also look at the FastLED implementation to see if I can find a good API that I have been missing out on.
				<br>

				I also did more research on FreeRTOS and tried to understand tasks more deeply. This is because our final code will require FreeRTOS to balance the many tasks thats will be completed.
				<br>

				When I was in the lab with Graeme, I did a little bit more practice soldering. I soldered some of the 3-pin connector on one of our boards. However, he had realized it was uneven so he had to desolder it.
				Nonetheless, it was good practice.
				<br>
				Documents:<br>
				<img src="Team/progress/progress1pics/desmoscalc.jpg" style="width:200px;height:200px;">
				<img src="Team/progress/progress1pics/whitelights.jpg" style="width:200px;height:200px;">
				<img src="Team/progress/progress1pics/pwm.jpg" style="width:200px;height:200px;">
				<img src="Team/progress/progress1pics/blinking.gif" style="width:200px;height:200px;">
				
			</p>
				

			<h4>Weeks Spring Break-10:</h4>
            <b>Date:</b> 3/24/23 <br>
            <b>Total hours:</b> 15<br>
            <b>Description of project design efforts:</b><br>
			<p>
				Over spring break, I came in on Monday and Tuesday to work with Avik on the final PCB design. We got a lot of help from Joe and redesigned it a few times. We settled on a 2-layer
				design with horizontal traces, small traces and components on layer 1 and only horizontal traces on layer 2. We also put all the power planes on layer 1, and saved layer 2 for DGND and AGND.
				We ordered at the end of Tuesday.
				<br>
				On Tuesday, I took the Bill of Materials from Avik and sent out the purchase request.
				<br>
				On Thursday, I sat with Graeme and went over our current inventory. We also inspected the PCB for shorts and used the DMM to make sure the planes were shorted/not shorted as required.
				He began to solder the power circuit and I tried to assist him wherever possible. This included purchasing some extra capacitors as the size
				is difficult to solder. We also realized we had the wrong inductor so I ordered the correct one.
				<br>
				On Friday, I came in shortly to work on soldering and did some practice on a device I had brought in from home. This was my first experience soldering so Graeme gave me lots of help.
				<br>
			</p>

			<h4>Weeks 8-9:</h4>
            <b>Date:</b> 3/10/23 <br>
            <b>Total hours:</b>50<br>
            <b>Description of project design efforts:</b><br>
			<p>
			I verified all major components for the PCB design by checking each component's data sheet and comparing it to the footprint associated to each part.
			I spent about 6 hours working on the presentation with the rest of team. This included updating the packaging specifications to match new information from the PCB design.
			After the presentation, I spent 40 hours in lab from Sunday to Friday. This included working with the team to prototype different microphones. All of my work was concerning the 
			amplifier that Joe gave us the design for. It was very important that this part was prototyped and completed ASAP so we could finalize our design. I isolated every section of the amplifier circuit
			and tested everything individually. This gave me the conclusion that we had not been supplying our LM324 with enough voltage. I rebuilt the circuit and got very good results with 
			the correct power to the LM324. I have attached photos of oscilloscope readings with Gain (A_v) = 10. However, this is not acceptable for our ADC as it can only read 0V-3.3V.
			Graeme and I worked together to modify this circuit and continuously recalculate values to lower the Gain and Input voltage to an acceptable range that would not damage our microcontroller.
			I have attached photos that demonstrate our formulas.
			<br>
			After this was complete, we prototyped the entire circuit on a breadboard, often needing to recalculate different voltage offsets. This was a sizable task to ensure our final design would work.
			Afterwards, me and Graeme made sizable changes to our schematic, redesigning every major analog component with prototyped and confirmed values. We also did lots of research and planned the 
			use of every microcontroller pin that would be important for our design. We found backups for every pin in case of a problem in prototyping. We also spent a lot of time figuring out where
			decoupling capacitors would go, as this was a new concept to both of us.
			<br>
			On Friday, the rest of the group met and we fixed all errors on the schematic and analyzed every pin of every component. This included creating global headers for DGND, AGND,5V,Vcc and creating headers where
			LED pins could be connected. We spent a few hours working on the PCB layout, essentially starting from scratch. I left after a few hours as I was feeling very tired.
			<br>
				Documents:<br>
				<img src="Team/progress/progress1pics/formulas.jpg" style="width:200px;height:200px;">
				<img src="Team/progress/progress1pics/AUX_circuit.jpg" style="width:200px;height:200px;">
				<img src="Team/progress/progress1pics/amp_voltage.jpg" style="width:200px;height:200px;">
				<img src="Team/progress/progress1pics/gpio.jpg" style="width:200px;height:200px;">
				<img src="Team/progress/progress1pics/gain10.jpg" style="width:200px;height:200px;">
				
			</p>

			<h4>Week 7:</h4>
            <b>Date:</b> 2/24/23 <br>
            <b>Total hours:</b> 12<br>
            <b>Description of project design efforts:</b><br>
			<p>
				Saturday, I spent 4 hours working on the FFT library that Graeme and I were trying to get working. After some fiddling with the example programs and careful
				testing of the functions (a few functions were completely useless/incorrect), I was able to get the FFT evaulation to work. I was at my apartment so I didn't have
				a way to connect to the ADC readings, so I came into lab and merged my program with the ADC sampling program from last week. As of right now, the program samples continuously,
				then computes FFT on the sample. It does not send messages to the message sender as I realized we could not use FastLED library for this. This is because in the new ADC sampling
				library, we are already using I2S to drive the ADC sampling. Therefore, we must use a non-I2S library to drive our LEDs. We will probably have to use RMT but I was very
				happy with the progress I stopped for the day.

				Monday, I came in for an hour and updated the website and sent some procurement documents through. 

				Tuesday, I stayed for an hour after lab and architected the general design and user control flow for the Android application. I have attached a picture in the documents below.
				I took input from Kahaan on his tests sending information from an Android phone to the ESP and incorporated them in the design, particularly the use of a 64-bit integer that would
				contain all information required from any information sent from the application. I came back before lecture and built the first few pages of the design in Figma. I will include screenshots
				of the completed design below. After lecture, I looked through our footprints and verified all of them. Avik came half-way through this process and we looked at the footprints which I 
				was not able to verify. We found some problems, particularly with the analog multiplexxer and the amplifier's footprints. 

				Wednesday, I did not come into lab but I finished the first draft of the app. Here is the link to see it, I have attached all animations so you can see a "simulation" of the app in 
				prototyping page: https://www.figma.com/file/GtGFT4a1HnDf2sjWmMkoc9/Android-App-Mockup?node-id=0%3A1&t=deuA5tb3YKjDUU1b-1 I have also attached a screenshot of all the assets required.
				Figma is very useful because we can play with general design, but the program will also generate assets that are usable in Android Studio. This will fall to the backburner until spring break is over.
				
				<br>
				Documents:<br>
				<img src="Team/progress/progress1pics/appdesign.jpg" style="width:200px;height:200px;">
				<img src="Team/progress/progress1pics/appdraft1.jpg" style="width:200px;height:200px;">

			</p>

			<h4>Week 6:</h4>
            <b>Date:</b> 2/17/23 <br>
            <b>Total hours:</b> 8.5<br>
            <b>Description of project design efforts:</b><br>
			<p>
				Saturday, came into lab and worked with Avik on the CAD models required for the Mechanical Overview. Talked about the final design and got some valuable input on 
				me and Graeme's mockup. Went home and finished up all the remaining documentation. Spent a decent amount of time considering parts and location in the PCB housing.
				<br>
				Tuesday, got the continuous adc sampling working with ESP-IDF. Still unable to associate actions to the callback generated when ADC sampling is complete.

				Friday, got very basic actions (changing a volatile global value) associated with the callback generated by ADC reference frame being full. 
				Then me and Graeme went to Home Depot to look at materials for our prototype. We made a list of items we wanted and will be sending in the parts procurement items soon. I went back to lab to 
				start working on the actions I want the adc callback to do. I was having trouble importing the esp-dsp library but got it work in the end.
				I have attached some photos from the trip below:
				<br>
				Documents:<br>
				<img src="Team/progress/progress1pics/wood.jpg" style="width:200px;height:200px;">
				<img src="Team/progress/progress1pics/plank.jpg" style="width:200px;height:200px;">
				<img src="Team/progress/progress1pics/glue.jpg" style="width:200px;height:200px;">
				<img src="Team/progress/progress1pics/stain.jpg" style="width:200px;height:200px;">
				<img src="Team/progress/progress1pics/varnish.jpg" style="width:200px;height:200px;">
			</p>

			<br>			

			<h4>Week 5:</h4>
            <b>Date:</b> 2/10/23 <br>
            <b>Total hours:</b> 12.5<br>
            <b>Description of project design efforts:</b><br>
            <p>
				Tuesday, after in-lab conversation with Graeme, I started integrating a few components together into one program. These being the Graeme's almost-done FFT program,
				my LED basic lightup program, and the half-completed Gaussian filter I was building. First thing I did was look at Graeme's FFT program which was returning incorrect
				frequncies. The frequencies returned were consistently off by a factor or 3.26 or 4.12 depending on setup. I looked at some online tutorials and start removing dead code 
				that was making the code run slower. After a while, I was able to get reproducibly correct values for frequency ranges (500,1500). I realized that the program was working correctly,
				but had the wrong values for total samples per loop and the frequency in which ADC samples are taken. I had gotten (500,1500) frequency ranged correctly isolated working with 
				Samples,SamplesFreq = 64,1000. I realized that the total samples would need to be raised to get the low frequencies correctly isolated. I implemented a test with Samples=128 then 256 then 512.
				I started getting more and more correct values for the low frequency values. At 512 samples, I was getting a value within 0.1% for values 20Hz to 50Hz. This was very promising so I started to 
				try to figure out why the high frequencies were still off. I started experimented with a constant sample value = 512 and changing the sample frequency up and down. After many tests, I 
				I was unable to realize I could not isolate frequencies above or equal to half my sampling frequency. I had a quick conversation with Graeme and he explained that this was due to
				the Nyquist Sample Rate which states that you cannot sample a signal with a frequency less than double the original frequency, which matched my experiments exactly. 
				<br>
				I changed my focus and attended Prof. Comer's office hours. I had watched a few videos and read the textbook for Convolution. Convolution is the basis of the Gaussian Filter that
				I was building for noise reduction. But I was unsure how exactly convolving an original sample with its guassian distribution would result a smoothed sample. She explained to me that
				I had misunderstood the gaussian distribution that was to be used for convolution. She explained that I had to implement a Gaussian distribution independent of my original sample. Therefore,
				my work last week building the Gaussian distribution of our sample was useless. I have attached a photo of the paper Prof. Comer explained the concept to me on. 
				<br>
				Had some conversations with Graeme where we talked more about the audible frequencies. Came to the conclusion the range (20,16000) is most useful. Therefore, our ADC must
				sample at a rate of at least 320000. I showed him my work and we started to figure out to get the ADC to sample at that rate. For some reason, we get useless data at any sample frequencies
				above 10k. We think this is related to the true sampling rate of our onboard ADC.
				
				<br>
				Wednesday, came into lab and made changes to the FFT and LED light up integrated program to correctly split up the frequencies (20,16000) into 6 bins (Graeme's input). I started implementing
				noise reduction with a Gaussian filter. I was/am unsure of the correct window size and sigma value to make an appropriately smoothed input. I took readings from a 1Hz pure sinusoidal wave
				and made sigma a function of the window. I have included the relevant spreadsheet below. The larger the window, the more smoothed the wave is. For now, the smoothing is fine but we will have to 
				find out the perfect value from continuing experiments. Then, I worked with Graeme to diagnose the problem. We came to the conclusion that we need to test ADC's max sampling capacity. I was not present
				for Graeme and Avik's test of the capability of the ADC.

				<br>
				I arrived after they were getting the conclusion of the test and talked with Avik to evaluate the cause of this problem. They came to the conclusion that our currentsampling system has a large
				computing load. This load does not allow the ADC to correctly sample when we want it to sample above 10k Hz. The solution to this problem is to drive the sampling with a timer of 40 kHz frequency.
				This value is from the Nyquist Sample Rate, which needs to be double our goal frequency. I talked to Avik about this and he gave me a good gameplan how to rework our program. It means that we will have
				to abandon the Arduino framework and use espressif32. This is a large undertaking that we will be doing. It essentially means recoding everything to get away from the loop() and setup() system and 
				be able to use a main() function that will be change to control flow off timers.
				
				<br>
				Friday, I got to work on the new program in Espressif32-IDF framework. I built a Hello World program and started working on timers and ADC sampling. I got basic ADC sampling not driven off a timer. 
				This was useful but the library was deprecated so I started converted it to the new ADC library, which allows for continuous samples. This essentially calls an interrupt after our sample array is filled.
				It is exactly what we are looking for. I couldnt get it to call a basic function in the handler but the progress was still useful. When Graeme got to lab, we started considering the display for our 
				project. We  talked with Joe and looked at different materials. I have attached a photo of our drawing below. We will plan to get materials for this next week.
				<br>
				Documents:<br>
				<img src="Team/progress/progress1pics/gausspaper.jpg" style="width:200px;height:200px;">
				<img src="Team/progress/progress1pics/display.jpg" style="width:200px;height:200px;">
			</p>

			<br>

            <h2>Progress Report for Anurag Numboori</h2>
			<h4>Week 4:</h4>
            <b>Date:</b> 2/3/23 <br>
            <b>Total hours:</b> 11<br>
            <b>Description of project design efforts:</b><br>
            <p>
				Tuesday, started researching Neopixel and FastLED libraries. Discovered FastLED uses neopixel to drive LEDs. Used FastLED to
				start the basis of our final displays with the LEDs. Got a system working for a series LED configuration with a customizable amount of LED devices. 
				My first idea is to map 5 bins of frequencies to 5 "bins" of LEDs. We will customize internal bins inside our main 5 bins. Then, depending on the frequency
				returned by FFT, we will illuminate the "sub-bins" of the bin that the frequency corresponds to. I did a first mockup of this idea without the 
				changing colors for sub-bins as I have not calculated that yet. As our FFT was not completed yet, I used randomly generated numbers for frequency.
				The program will probably end up using multiples of 5.At some point, we will likely not use the library and instead use the old PWM signals I was working on. 
				But right now, we are trying to get as much possible working as fast as possible. I attached a link to the documentation I was using below.
				<br>
				Wednesday, I realized that I had not considered the cases in which users have less than 5 LEDs connected. I made some changes to my algorihm.
				I am still working to create the seperation of colors inside of "sub-bins". Note for the second test, I removed the randomly generated frequencies and instead
				put one frequency for each bin for bins 1-5. You cannot see the 5th bin as there are only 4 connected (proof of &#605 working).
				<br>
				Thursday, came into lab. Started realizing we need a beat detection algorithm. Researched this instead of continuing the different output modes.
				Different output modes for prototyping are still useful, but only 1 is required for full prototyping. The next output modes I will build will be for parallel configurations
				and one in which there are no 5 LED "bins" and instead ALL the LEDs flash the corresponding frequency color. Had a long conversation with Avik about the usefulness of noise minimization.
				Made it clear that the next goal after a rudimentary beat detection algo is to work on a software solution for noise control. 
				<br>
				Talked to Prof. Cormer to figure out a good direction for noise reduction algorithm. Described problem and intended goal and she reccomended Gaussian Blur.
				Did some research into the properties of Gaussian Blur and decideded it would be useful. This is because it acts like a software low pass filter but doesn't
				fully filter the high frequencies that will be useful (hi-hats). 
				<br>
				Friday, I got to lab and got to work on build a basic 1-D gaussian noise reduction program that will display results of ADC readings
				and the gaussian blur on ADC readings. I attached my main source of information below. It has been a long time since I worked with statistics so it took a long amount of time to correctly use and calculate
				the standard deviation and variance for the Gaussian distribution. I used a graphing application to check the correctness of my values. I have attached a screenshot of
				it below. I was successful in the end and have attached my text file below that demonstrates the Gaussian distribution being built for an signal input through the AUX-in.
				The next step in the noise reduction program is to combine the outputted Gaussian distribution with a convolution function that will return the input signal with noise
				reduction on it.  
				<br>
				Documents:<br>
				<a href="https://github.com/FastLED/FastLED/wiki/Rgb-calibration">FastLED Documentation</a> <br>
				<a href="https://homepages.inf.ed.ac.uk/rbf/HIPR2/gsmooth.htm">Information on Gaussian Distribution</a> <br>
				<a href="Team/progress/progress1pics/gaussian.txt"> Results of building a Gaussian </a><br>
				<img src="Team/progress/progress1pics/GaussianDistribution.png" style="width:200px;height:200px;">
				<img src="Team/progress/progress1pics/flashing.gif" style="width:200px;height:200px;">
			</p>

			<br>

            <h4>Week 3:</h4>
            <b>Date:</b> 1/27/23 <br>
            <b>Total hours:</b> 7<br>
            <b>Description of project design efforts:</b><br>
            <p>
				Tried getting bluetooth basic connection working. Got it working. Worked out the duty cycle for DATA control for LEDs.
				Worked with PWM outputs to build duty cycle on protype circuit. On Thursday, I got duty cycles working from PWN outputs.
				This allows us to build 0 and 1 inputs to our data pin on the LED.
				On friday, I built some control flows for the 0,1 duty cycle inputs to our data pin. We also got the LED strip in the mail.
				I tried testing the inputs but could not get anything productive to work. I accidentally destroyed 3 LEDs but thankfully I had disconnected
				them from the rest of the strip so everything else is fine. The team was able to use a library for changing the colors of the LEDs, so we will probably not 
				use the duty cycle with PWM for the data pin. Worked on documents with the team.
				<br>
				Documents:<br>
				<img src="Team/progress/progress1pics/IMG_4288.jpg" style="width:200px;height:200px;">
				<img src="Team/progress/progress1pics/IMG_4299.jpg" style="width:200px;height:200px;">
				<img src="Team/progress/progress1pics/IMG_4301.jpg" style="width:200px;height:200px;">
			</p>

			<br>

            <h4>Weeks 1-2:</h4>
            <b>Date:</b> 1/20/23 <br>
            <b>Total hours:</b> 13 <br>
            <b>Description of project design efforts:</b>
			<p>
				This week was mostly spent researching, fleshing out the design, and getting hardware to prototype with.
				First thing I did was get the website hosted and customized for our team. I then reached out to some friends and procured addressable LED strips for prototyping.
				Worked with the team to figure out how to bias the strip for different colors. The ones I was able to get had 4 pins: one each for RGB and 1 for 12V. This proved useful for testing but
				unusable for the final design. I kept looking for hardware we could use for prototyping (microphone, TRRS jack) and worked with Graeme to test out our microphone without amplification.
				Our initial tests were inconclusive as we didn't have the necessary amplification. I was not present for the construction of the amplifier circuit. 
				I then got the prototyping environment set up on my laptop and worked with Graeme to test the ESP32's onboard ADC with signals from the AD2. There was some friction with the IDE as both of us have never
				used PlatformIO and had to troubleshoot out a few bugs before we could read serial communcation (so we could see the ADC readings). The AD2 input signals represented a hypothetical input audio wave.
				I am in the middle of creating a data visualization tool to see how accurate our sampling with the onboard ADC is, but I expect to finish it next week. 
				This tool will tell us if we need to depend on a seperate module for the ADC or we can use the onboard ADC. Spent some time with the other members thinking about how to consolidate the final functionality
				and we settled on the 3 Modes switching from external controls. I did some research into the FFT algorithm that we will need to start working with after we have audio input from the ADC. I also did some research
				on how diodes work to see how useful a Zener Diode will be for stepping power down and to brush up on general operations for driving the LEDs. Finally, worked with the team to finish up documentation required for the course.
				<br>
				Note: I forgot to take photos this week but I will try to have many for the next weeks.
			</p>

			<br>
        </div>
	
		<!-- Instantiate global footer. Any changes to the footer should be made through the top-level file "footer.html" -->
		<div id="footer"></div>
    </div>
</div>

<!--JS-->
<script src="js/jquery.js"></script>
<script src="js/jquery-migrate-1.1.1.js"></script>

<script type="text/javascript">
$(document).ready(function() {
    $("#header").load("header.html");
	$("#menu").load("navbar.html");
	$("#footer").load("footer.html");
});
</script>
</body>
</html>
